function [out] = l_plus_s(xfm, samp, varargin)
%function [est, err, fErr] = iht_ms(xfm, samp, rank, step, shrink, maxIter, tol, truth, est)
%
%   Last Modified by Mark Chiew
%   Oct 2016
%   -   Switched the order of hard thresholding/shrink, and data consistency
%       Ending on the data consistency step seems to work a bit better
%   -   Added temporal constraints
%
%   Modified by Mark Chiew
%   Jun 2014
%
%   Outputs:    est         is the final matrix estimate 
%               err         is the error of the estimated values at the sampled
%                           k-space locations only
%               fErr        is the total error of the entire estimated matrix
%                           (only computed if ground truth is provided)
%
%   Inpute:     xfm         the nufft/fft-based measurement model transform
%                           generated by the transform class
%               samp        sampled data points, the size/shape of this should
%                           match the output of xfm*est
%               step        scales the size of the changes to the iteratively
%                           updated estimate matrix
%               shrink      scales the shrinkage parameter (0 < shrink < 1)
%               maxIter     the maximum number of iterations to be performed
%               tol         minimum update tolerance, if the change in the
%                           estimate matrix is below tol, iteration stops
%               truth       the "true" full data, used to calculate the full
%                           error
%               est         initial matrix estimate (optional)

%===========================================================
%   Script Setup and Parse Inputs
%===========================================================
%   Welcome Message
disp('L+S');

%   Parse Inputs
disp('Parsing Inputs');
p       =   inputParser;
msize   =   xfm.msize;

p.addRequired('xfm');
p.addRequired('samp');

p.addParamValue('L',          0,      @isscalar);
p.addParamValue('S',          0,      @isscalar);
p.addParamValue('step',       1,      @isscalar);
p.addParamValue('maxIter',    50,     @isscalar);
p.addParamValue('tol',        1E-4,   @isscalar);
p.addParamValue('truth',      [],     @(x) prod(size(x)) == prod(msize));
p.addParamValue('est',        [],     @(x) isequal(size(x), msize));
p.addParamValue('vSparse',    'FFT'   );

p.parse(xfm, samp, varargin{:});
maxIter     =   p.Results.maxIter;
tol         =   p.Results.tol;
step        =   p.Results.step;
truth       =   p.Results.truth;
ests        =   p.Results.est;
vSparse     =   p.Results.vSparse;
L_L         =   p.Results.L;
L_S         =   p.Results.S;

clear p;

%===========================================================
%   Initialization
%===========================================================
disp('Performing Initialisation');

%   Compute starting error and full-error estimates (if available) using the 
%   Frobenius norm (normalised)
%   Note: The Frobenius norm of a matrix A is defined as sqrt(Tr(A*A^H))
%   or alternatively the sqrt of the sum of the squared entires
err     =   1;
fErr    =   inf;
if ~isempty(truth)
    truthnorm   =   norm(truth(:));
else
end

dims    =   xfm.Nd;
nt      =   msize(2);

%est =   complex(zeros(msize, 'single'));
%est =   xfm'*samp;

%   Compute inverse
if isnumeric(vSparse)
    ivSparse    = inv(vSparse); 
end

%   Prep for Toeplitz Embedding
xsamp   =   xfm'*samp;
est     =   xsamp;

%   Initialize some iteration parameters
iter    =   1;
estS    =   zeros(msize);
%estL    =   repmat(mean(est,2),1,nt);
%estL    =   zeros(msize);
estL    =   est;
est0    =   est;
L       =   0;
S       =   0;
dS      =   estS(:,1:end-1);
update  =   inf;


%===========================================================
%   Main Iteration Loop
%===========================================================
disp('Beginning Iterations');
%fprintf(1, '%-5s %-16s %-5s %-16s %-16s %-16s\n', 'Iter','Data','Rank','L','S','Cost');
fprintf(1, '%-5s %-16s\n', 'Iter','Update');
while iter <= maxIter && update > tol

    %   Low Rank (Singular Value Thresholding)
    [U, Sig, V] =   lsvd(est - estS);
    Sig2        =   diag(max(diag(abs(Sig)) - step*L_L, 0));
    L           =   sum(abs(diag(Sig2)));
    estL    =   U*Sig2*V';

    %   Sparsity (Soft Thresholding)
    switch vSparse
    case 'FFT'
        estS    =   fft(est-estL,[],2);
        estS    =   exp(1j*angle(estS)).*max(abs(estS) - step*L_S, 0);
        S       =   sum(abs(estS(:)));
        estS    =   ifft(estS,[],2);
    case 'TV'
        dS      =   dS + 0.25*diff(est-estL,1,2);
        dS      =   exp(1j*angle(dS)).*reshape(max(min(abs(dS(:)),L_S/2),-L_S/2),[],nt-1);
        dS(isnan(dS)) = 0;
        adjS(:,1) = -dS(:,1);
        adjS(:,2:nt-1) = -diff(dS,1,2);
        adjS(:,nt) = dS(:,end);
        estS    =   est - estL - adjS;
    otherwise
        estS    =   (est-estL)*vSparse;
        estS    =   exp(1j*angle(estS)).*max(abs(estS) - step*L_S, 0);
        S       =   sum(abs(estS(:)));
        estS    =   estS*ivSparse;
    end

    %   Update estL after estS estimated
    estL    =   U*Sig2*V';

    est =   (estL + estS) + step*(xsamp - mtimes2(xfm, estL + estS));

    %   Update the error and change metrics
    %{
    err2(iter)  =   L_L*L;
    err3(iter)  =   L_S*S; 
    if mod(iter,5)==0
        rnd_idx     =   randperm(nt, round(nt/10));
        err1(iter)  =   10*0.5*norm(reshape(samp(:,rnd_idx,:)-mtimes(xfm, estL(:,rnd_idx)+estS(:,rnd_idx),rnd_idx),[],1)).^2;  %approx
        cost(iter)  =   err1(iter) + err2(iter) + err3(iter);
        fprintf(1, '%-5d %-16G %-5G %-16G %-16G %-16G\n', iter, err1(iter), nnz(Sig2), err2(iter), err3(iter), cost(iter));
    else
        fprintf(1, '%-5d %-16s %-5G %-16G %-16G %-16s\n', iter, '-', nnz(Sig2), err2(iter), err3(iter), '-');
    end
    %}


    %   Update iteration counter
    update  =   norm(est(:)-est0(:))/norm(est0(:));
    fprintf(1, '%-5d %-16G\n', iter, update);

    est0    =   est;
    iter    =   iter + 1;
   
end

out.L   =   estL;
out.S   =   estS;
disp('Finished'); 
