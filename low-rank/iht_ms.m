function [ests, cost] = iht_ms(xfm, samp, varargin)
%function [ests, err] = iht_ms(xfm, samp, rank, step, shrink, maxIter,...
%                                   tol, est)
%
%   Last Modified by Mark Chiew
%   Nov 2016
%   -   Modified update criteria, and added option for looping over timepoints
%   
%   Oct 2016
%   -   Switched the order of hard thresholding/shrink, and data consistency
%       Ending on the data consistency step seems to work a bit better
%   -   Added temporal constraints
%
%   Modified by Mark Chiew
%   Jun 2014
%
%   Outputs:    est         is the final matrix estimate 
%               err         is the error of the estimated values at the sampled
%                           k-space locations only
%   Inputs:     xfm         the nufft/fft-based measurement model transform
%                           generated by the transform class
%               samp        sampled data points, the size/shape of this should
%                           match the output of xfm*est
%               rank        the rank of the matrix to be estimated
%               step        scales the size of the changes to the iteratively
%                           updated estimate matrix
%               shrink      scales the shrinkage parameter (0 < shrink < 1)
%               maxIter     the maximum number of iterations to be performed
%               tol         minimum update tolerance, if the change in the
%                           estimate matrix is below tol, iteration stops
%               est         initial matrix estimate (optional)


%===========================================================
%   Script Setup and Parse Inputs
%===========================================================
%   Welcome Message
disp('Accelerated Iterative Hard Thresholding with Matrix Shrinkage with Temporal Constraints 2');

%   Parse Inputs
disp('Parsing Inputs');
p       =   inputParser;
msize   =   xfm.msize;

p.addRequired('xfm');
p.addRequired('samp');

p.addParamValue('rank',       1,      @isscalar); 
p.addParamValue('step',       0.1,    @isscalar);
p.addParamValue('shrink',     0.5,    @isscalar);
p.addParamValue('maxIter',    500,    @isscalar);
p.addParamValue('tol',        1E-4,   @isscalar);
p.addParamValue('est',        [],     @isstruct);
p.addParamValue('verbose',    false,  @islogical);
p.addParamValue('accel',      true,   @islogical);

p.parse(xfm, samp, varargin{:});
r           =   p.Results.rank;
step        =   p.Results.step;
shrink      =   p.Results.shrink;
maxIter     =   p.Results.maxIter;
tol         =   p.Results.tol;
ests        =   p.Results.est;
verbose     =   p.Results.verbose;
accel       =   p.Results.accel;

clear p;

%===========================================================
%   Initialization
%===========================================================
disp('Performing Initialisation');

%   Compute starting error and full-error estimates (if available) using the 
%   Frobenius norm (normalised)
%   Note: The Frobenius norm of a matrix A is defined as sqrt(Tr(A*A^H))
%   or alternatively the sqrt of the sum of the squared entires
err     =   1;

dims    =   xfm.Nd;
nt      =   msize(2);

if isempty(ests)
    U   =   zeros(msize(1),1);
    V   =   zeros(msize(2),1);
else
    U   =   single(ests.u);
    V   =   single(ests.v);
end
est =   U*V';

%   Initialize some iteration parameters
iter    =   1;
errnorm =   norm(samp(:));
%k_est   =   zeros(size(samp));
d       =   xfm'*samp;
y       =   est;
est0    =   est;
t1      =   1;
update  =   1;
Sig2    =   0;
thresh  =   0;

%===========================================================
%   Main Iteration Loop
%===========================================================
disp('Beginning Iterations');
if verbose
    fprintf(1, '%-5s %-16s %-16s %-16s %-16s\n', 'Iter','Update','Data.Con.','Nuc.Norm.','Cost');
end
while iter <= maxIter
    
    %   Compute k-space data on sampled points
    %   Data consistency "gradient" step
    %k_est   =   samp - xfm*y;
    %est     =   y + step*(xfm'*k_est);
    est     =   y + step*(d - xfm.mtimes2(y));

    %   Hard thresholding and matrix shrinkage
    [U, Sig, V] =   lsvd(est, r);
    thresh      =   shrink*Sig(end);
    Sig2        =   max(abs(Sig) - thresh, 0);
    V           =   V*Sig2;
    est         =   U*V';

    %   Acceleration
    t2  =   (1+sqrt(1+4*t1^2))/2;
    y   =   est + accel*((t1-1)/t2)*(est - est0);

    %   Update the error and change metrics
    %err1(iter+1) =   norm(k_est(:)).^2;
    err1(iter+1) =   0;
    err2(iter+1) =   sum(abs(diag(Sig2)));

    %   Update the error and change metrics
    update      =   norm(est(:)-est0(:))/norm(est(:));

    %   Compute cost
    cost(iter)  =   0.5*err1(iter+1) + thresh*err2(iter+1);

    %   Display iteration summary data
    if verbose
        fprintf(1, '%-5d %-16G %-16G %-16G %-16G\n', iter, update, err1(iter+1), err2(iter+1), cost(iter));
    end

    %   Check stop-iteration conditions
    if iter> 2 && abs(update) < tol
        disp('Minimum estimate update reached, stopping');
        break;
    end

    %   Update iteration counter
    iter    =   iter + 1;
    est0    =   est;
    t1      =   t2;
end

[U, Sig, V] =   lsvd(est,r);
ests.u      =   U;
ests.v      =   V*Sig;
disp('Finished'); 
